diff --git a/src/eventloop/eventloop.go b/src/eventloop/eventloop.go
index 28df04e..c248222 100644
--- a/src/eventloop/eventloop.go
+++ b/src/eventloop/eventloop.go
@@ -34,6 +34,7 @@ type result struct {
 	err    error
 	conn   singleinstance.Conn
 	stdout bool
+	cancel context.CancelFunc
 }
 
 // New creates a new event loop with defaults based on config.
@@ -144,16 +145,16 @@ func (l *Loop) handleConn(ctx context.Context, conn singleinstance.Conn) {
 	}
 
 	jobCtx, cancel := context.WithTimeout(ctx, l.deadline)
-	defer cancel()
 
 	// Start countdown popup for delegated --run-once requests
 	_ = popup.StartCountdown(int(l.deadline.Seconds()))
 
 	l.setBusy(true)
 	submitted := l.pool.Submit(jobCtx, region, func(text string, err error) {
-		l.results <- result{text: text, err: err, conn: conn, stdout: req.OutputToStdout}
+		l.results <- result{text: text, err: err, conn: conn, stdout: req.OutputToStdout, cancel: cancel}
 	})
 	if !submitted {
+		cancel() // Clean up context if job wasn't submitted
 		l.setBusy(false)
 		_ = popup.Close()
 		_ = conn.RespondError("Busy, please retry")
@@ -163,7 +164,13 @@ func (l *Loop) handleConn(ctx context.Context, conn singleinstance.Conn) {
 }
 
 func (l *Loop) handleResult(res result) {
-	defer func() { l.setBusy(false) }()
+	log.Printf("handleResult: called with text length=%d, err=%v, conn=%v", len(res.text), res.err, res.conn != nil)
+	defer func() {
+		l.setBusy(false)
+		if res.cancel != nil {
+			res.cancel()
+		}
+	}()
 	// Pipe-client path
 	if res.conn != nil {
 		defer res.conn.Close()
@@ -187,48 +194,66 @@ func (l *Loop) handleResult(res result) {
 		return
 	}
 	// Resident hotkey path
+	log.Printf("handleResult: resident hotkey path")
 	if res.err != nil {
 		// Timeout or error - just close popup silently
+		log.Printf("handleResult: error in resident path: %v", res.err)
 		_ = popup.Close()
 		return
 	}
+	log.Printf("handleResult: writing %d chars to clipboard", len(res.text))
 	if err := clipboard.Write(res.text); err != nil {
+		log.Printf("handleResult: clipboard error: %v", err)
 		_ = popup.Close()
 		_ = popup.Show("Clipboard error")
 		return
 	}
 	// Update countdown popup with result text
+	log.Printf("handleResult: updating popup with result")
 	_ = popup.UpdateText(res.text)
+	log.Printf("handleResult: hotkey flow complete")
 }
 
 func (l *Loop) handleHotkey(ctx context.Context) {
+	log.Printf("handleHotkey: called")
 	if l.busy {
+		log.Printf("handleHotkey: busy, skipping")
 		_ = popup.Show("Busy, please retry")
 		return
 	}
+	log.Printf("handleHotkey: selecting region")
 	region, cancelled, err := l.selectRegion(ctx)
 	if err != nil {
+		log.Printf("handleHotkey: selection error: %v", err)
 		_ = popup.Show("Selection error")
 		return
 	}
 	if cancelled {
+		log.Printf("handleHotkey: selection cancelled")
 		return
 	}
 
+	log.Printf("handleHotkey: region selected %dx%d, creating job context with deadline %v", region.Width, region.Height, l.deadline)
 	jobCtx, cancel := context.WithTimeout(ctx, l.deadline)
-	defer cancel()
 
 	// Start countdown popup immediately
+	log.Printf("handleHotkey: starting countdown popup")
 	_ = popup.StartCountdown(int(l.deadline.Seconds()))
 
 	l.setBusy(true)
+	log.Printf("handleHotkey: submitting job to worker pool")
 	ok := l.pool.Submit(jobCtx, region, func(text string, err error) {
-		l.results <- result{text: text, err: err, conn: nil, stdout: false}
+		log.Printf("handleHotkey: callback invoked with text length=%d, err=%v", len(text), err)
+		l.results <- result{text: text, err: err, conn: nil, stdout: false, cancel: cancel}
 	})
 	if !ok {
+		log.Printf("handleHotkey: submit failed, pool busy")
+		cancel() // Clean up context if job wasn't submitted
 		l.setBusy(false)
 		_ = popup.Close()
 		_ = popup.Show("Busy, please retry")
+	} else {
+		log.Printf("handleHotkey: job submitted successfully")
 	}
 }
 
